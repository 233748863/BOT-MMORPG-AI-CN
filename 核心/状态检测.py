"""
状态检测模块
检测游戏中的血量和蓝量

功能:
- 血条检测
- 蓝条检测
- 平滑处理
- 校准工具
"""

import os
import json
import time
from typing import Tuple, Optional, Dict, List
from dataclasses import dataclass
from collections import deque
import numpy as np
import cv2
import logging

# 配置日志
logging.basicConfig(level=logging.INFO)
日志 = logging.getLogger(__name__)


@dataclass
class 状态检测结果:
    """状态检测结果"""
    血量百分比: float = 1.0
    蓝量百分比: float = 1.0
    血量置信度: float = 0.0
    蓝量置信度: float = 0.0
    检测时间: float = 0.0
    
    def to_dict(self) -> dict:
        return {
            '血量百分比': round(self.血量百分比, 3),
            '蓝量百分比': round(self.蓝量百分比, 3),
            '血量置信度': round(self.血量置信度, 3),
            '蓝量置信度': round(self.蓝量置信度, 3),
            '检测时间': round(self.检测时间, 4)
        }


class 平滑器:
    """
    检测结果平滑处理
    
    使用移动平均算法平滑检测结果，同时支持突变检测和快速响应。
    当检测到显著变化（超过突变阈值）时，会立即响应而不是平滑过渡。
    
    需求: 4.1, 4.2, 4.3
    """
    
    def __init__(self, 窗口大小: int = 5, 突变阈值: float = 0.1):
        """
        初始化平滑器
        
        参数:
            窗口大小: 平滑窗口大小，默认 5 帧（需求 4.2）
            突变阈值: 突变检测阈值，默认 0.1（10%）（需求 4.3）
        """
        if 窗口大小 < 1:
            raise ValueError("窗口大小必须大于等于 1")
        if not (0.0 <= 突变阈值 <= 1.0):
            raise ValueError("突变阈值必须在 0.0 到 1.0 之间")
        
        self._窗口大小 = 窗口大小
        self._历史: deque = deque(maxlen=窗口大小)
        self._突变阈值 = 突变阈值
        self._上次输出值: float = 1.0
        self._上次原始值: float = 1.0
        self._已初始化: bool = False
    
    @property
    def 窗口大小(self) -> int:
        """获取窗口大小"""
        return self._窗口大小
    
    @property
    def 突变阈值(self) -> float:
        """获取突变阈值"""
        return self._突变阈值
    
    @property
    def 历史长度(self) -> int:
        """获取当前历史记录长度"""
        return len(self._历史)
    
    def 是否突变(self, 新值: float) -> bool:
        """
        检测是否发生突变
        
        参数:
            新值: 新的检测值
            
        返回:
            是否发生突变（变化超过阈值）
            
        需求: 4.3
        """
        if not self._已初始化:
            return False
        
        差异 = abs(新值 - self._上次输出值)
        return 差异 > self._突变阈值
    
    def 平滑(self, 值: float) -> float:
        """
        平滑处理
        
        使用移动平均计算平滑值。当检测到突变（变化 > 10%）时，
        立即响应新值而不是平滑过渡。
        
        参数:
            值: 原始检测值
            
        返回:
            平滑后的值，保证在 [0.0, 1.0] 范围内
            
        需求: 4.1, 4.2, 4.3
        """
        # 确保值在有效范围内
        值 = max(0.0, min(1.0, 值))
        
        # 首次调用，直接使用该值
        if not self._已初始化:
            self._历史.append(值)
            self._上次输出值 = 值
            self._上次原始值 = 值
            self._已初始化 = True
            return 值
        
        # 检测突变（需求 4.3）
        if self.是否突变(值):
            # 突变情况，清空历史并立即使用新值
            self._历史.clear()
            self._历史.append(值)
            self._上次输出值 = 值
            self._上次原始值 = 值
            return 值
        
        # 添加到历史
        self._历史.append(值)
        self._上次原始值 = 值
        
        # 计算平滑值（移动平均）（需求 4.1, 4.2）
        平滑值 = sum(self._历史) / len(self._历史)
        
        # 确保输出在有效范围内
        平滑值 = max(0.0, min(1.0, 平滑值))
        self._上次输出值 = 平滑值
        
        return 平滑值
    
    def 获取上次值(self) -> float:
        """获取上次输出的平滑值"""
        return self._上次输出值
    
    def 获取历史(self) -> list:
        """获取历史记录副本"""
        return list(self._历史)
    
    def 重置(self):
        """重置平滑器状态"""
        self._历史.clear()
        self._上次输出值 = 1.0
        self._上次原始值 = 1.0
        self._已初始化 = False


class 状态条分析器:
    """
    分析状态条填充程度
    
    使用 HSV 颜色空间分析状态条的填充比例。
    支持可配置的颜色范围和渐变颜色处理。
    
    需求: 2.1, 2.3
    """
    
    def __init__(self, 颜色配置: dict = None):
        """
        初始化分析器
        
        参数:
            颜色配置: HSV 颜色范围配置，支持以下格式:
                - 单一颜色: {"填充色": {"H_min": 0, "H_max": 10, ...}}
                - 渐变颜色: {"渐变色": [{"H_min": 0, ...}, {"H_min": 20, ...}]}
                
        需求: 2.2, 2.4
        """
        self.颜色配置 = 颜色配置 or self._默认颜色配置()
        self._填充阈值 = 0.3  # 认为该列有填充的阈值
    
    def _默认颜色配置(self) -> dict:
        """默认颜色配置"""
        return {
            "填充色": {
                "H_min": 0, "H_max": 180,
                "S_min": 50, "S_max": 255,
                "V_min": 50, "V_max": 255
            }
        }
    
    def 设置颜色配置(self, 颜色配置: dict):
        """
        设置颜色配置
        
        参数:
            颜色配置: HSV 颜色范围配置
            
        需求: 2.2
        """
        if 颜色配置:
            self.颜色配置 = 颜色配置
    
    def 设置填充阈值(self, 阈值: float):
        """
        设置填充检测阈值
        
        参数:
            阈值: 0.0-1.0 之间的值，表示列中需要多少比例的像素被认为是填充
        """
        self._填充阈值 = max(0.0, min(1.0, 阈值))
    
    def _创建颜色掩码(self, hsv图像: np.ndarray) -> np.ndarray:
        """
        创建颜色掩码，支持单一颜色和渐变颜色
        
        参数:
            hsv图像: HSV 颜色空间的图像
            
        返回:
            二值掩码
            
        需求: 2.4
        """
        掩码 = None
        
        # 处理渐变颜色配置
        if "渐变色" in self.颜色配置:
            渐变色列表 = self.颜色配置["渐变色"]
            for 颜色范围 in 渐变色列表:
                下界 = np.array([
                    颜色范围.get("H_min", 0),
                    颜色范围.get("S_min", 50),
                    颜色范围.get("V_min", 50)
                ])
                上界 = np.array([
                    颜色范围.get("H_max", 180),
                    颜色范围.get("S_max", 255),
                    颜色范围.get("V_max", 255)
                ])
                当前掩码 = cv2.inRange(hsv图像, 下界, 上界)
                
                if 掩码 is None:
                    掩码 = 当前掩码
                else:
                    掩码 = cv2.bitwise_or(掩码, 当前掩码)
        
        # 处理单一颜色配置
        elif "填充色" in self.颜色配置:
            填充色 = self.颜色配置["填充色"]
            下界 = np.array([
                填充色.get("H_min", 0),
                填充色.get("S_min", 50),
                填充色.get("V_min", 50)
            ])
            上界 = np.array([
                填充色.get("H_max", 180),
                填充色.get("S_max", 255),
                填充色.get("V_max", 255)
            ])
            掩码 = cv2.inRange(hsv图像, 下界, 上界)
        
        # 如果没有有效配置，返回全零掩码
        if 掩码 is None:
            掩码 = np.zeros(hsv图像.shape[:2], dtype=np.uint8)
        
        return 掩码
    
    def 分析(self, 区域图像: np.ndarray) -> Tuple[float, float]:
        """
        分析状态条
        
        通过 HSV 颜色空间分析状态条的填充程度。
        使用列扫描方法检测填充边界。
        
        参数:
            区域图像: 状态条区域图像 (BGR 格式)
            
        返回:
            (填充百分比, 置信度)
            - 填充百分比: 0.0-1.0 之间的值
            - 置信度: 0.0-1.0 之间的值，表示检测结果的可靠性
            
        需求: 2.1, 2.3
        """
        if 区域图像 is None or 区域图像.size == 0:
            return 1.0, 0.0
        
        try:
            # 确保图像是 3 通道
            if len(区域图像.shape) == 2:
                区域图像 = cv2.cvtColor(区域图像, cv2.COLOR_GRAY2BGR)
            
            # 转换到 HSV 空间进行颜色分析
            hsv = cv2.cvtColor(区域图像, cv2.COLOR_BGR2HSV)
            
            # 创建颜色掩码（支持渐变颜色）
            掩码 = self._创建颜色掩码(hsv)
            
            # 计算填充比例
            高度, 宽度 = 掩码.shape
            
            if 宽度 == 0 or 高度 == 0:
                return 1.0, 0.0
            
            # 按列统计填充像素比例
            列填充 = np.sum(掩码 > 0, axis=0) / 高度
            
            # 找到填充边界
            填充列 = 列填充 > self._填充阈值
            
            if not np.any(填充列):
                # 没有检测到填充，返回 0
                return 0.0, 0.5
            
            # 找到最右边的填充列（填充边界）
            填充索引 = np.where(填充列)[0]
            右边界 = 填充索引[-1] if len(填充索引) > 0 else 0
            
            # 计算百分比
            百分比 = (右边界 + 1) / 宽度
            
            # 计算置信度（基于填充区域的一致性）
            # 置信度越高表示填充区域越均匀
            填充区域 = 列填充[:右边界 + 1]
            if len(填充区域) > 0:
                置信度 = np.mean(填充区域)
            else:
                置信度 = 0.0
            
            # 确保返回值在有效范围内
            百分比 = min(1.0, max(0.0, 百分比))
            置信度 = min(1.0, max(0.0, 置信度))
            
            return 百分比, 置信度
            
        except Exception as e:
            日志.warning(f"状态条分析失败: {e}")
            return 1.0, 0.0
    
    def 检测填充边界(self, 区域图像: np.ndarray) -> int:
        """
        检测填充区域的右边界位置
        
        参数:
            区域图像: 状态条区域图像
            
        返回:
            右边界 x 坐标（像素位置）
            
        需求: 2.3
        """
        if 区域图像 is None or 区域图像.size == 0:
            return 0
        
        百分比, _ = self.分析(区域图像)
        宽度 = 区域图像.shape[1]
        return int(百分比 * 宽度)
    
    def 获取颜色配置(self) -> dict:
        """获取当前颜色配置"""
        return self.颜色配置.copy()


class 血量检测器:
    """
    检测游戏血条的填充百分比
    
    支持可配置的颜色范围，包括单一颜色和渐变颜色。
    默认检测红色血条，也支持绿色血条（如某些游戏中满血为绿色）。
    
    错误处理策略（需求 6.1, 6.2, 6.3）:
    - 检测失败时返回上次有效值
    - 连续失败超过 5 秒返回满血（1.0）
    - 记录所有检测失败和血量变化
    
    需求: 1.1, 2.1, 2.2, 2.4, 6.1, 6.2, 6.3, 6.4
    """
    
    # 默认红色血条颜色范围
    默认颜色配置 = {
        "填充色": {
            "H_min": 0, "H_max": 10,  # 红色色调
            "S_min": 100, "S_max": 255,
            "V_min": 100, "V_max": 255
        }
    }
    
    # 预设颜色配置：红色到黄色到绿色渐变（常见血条）
    渐变颜色配置 = {
        "渐变色": [
            # 红色（低血量）
            {"H_min": 0, "H_max": 10, "S_min": 100, "S_max": 255, "V_min": 100, "V_max": 255},
            # 橙色
            {"H_min": 10, "H_max": 25, "S_min": 100, "S_max": 255, "V_min": 100, "V_max": 255},
            # 黄色
            {"H_min": 25, "H_max": 35, "S_min": 100, "S_max": 255, "V_min": 100, "V_max": 255},
            # 绿色（满血）
            {"H_min": 35, "H_max": 85, "S_min": 100, "S_max": 255, "V_min": 100, "V_max": 255},
        ]
    }
    
    # 默认失败超时时间（秒）
    默认失败超时 = 5.0
    
    def __init__(self, 配置: dict = None):
        """
        初始化血量检测器
        
        参数:
            配置: 检测配置字典，支持以下字段:
                - 区域: (x, y, width, height) 血条区域
                - 颜色: 颜色配置字典
                - 平滑窗口: 平滑窗口大小
                - 使用渐变: 是否使用渐变颜色配置
                - 失败超时: 连续失败超时时间（秒），默认 5 秒
                
        需求: 1.1, 2.2, 6.2
        """
        self.配置 = 配置 or {}
        self.区域 = self.配置.get("区域", None)  # (x, y, width, height)
        
        # 颜色配置支持
        使用渐变 = self.配置.get("使用渐变", False)
        if 使用渐变:
            颜色配置 = self.配置.get("颜色", self.渐变颜色配置)
        else:
            颜色配置 = self.配置.get("颜色", self.默认颜色配置)
        
        self._分析器 = 状态条分析器(颜色配置)
        
        窗口大小 = self.配置.get("平滑窗口", 5)
        self._平滑器 = 平滑器(窗口大小)
        
        self._上次值 = 1.0
        self._上次置信度 = 0.0
        self._连续失败次数 = 0
        self._最大连续失败 = 10
        
        # 错误处理相关（需求 6.1, 6.2）
        self._失败超时 = self.配置.get("失败超时", self.默认失败超时)
        self._首次失败时间: Optional[float] = None
        self._上次成功时间: float = time.time()
        self._上次有效值 = 1.0  # 上次成功检测的值
        
        # 日志和诊断相关（需求 5.4, 6.3）
        self._检测统计 = {
            "总检测次数": 0,
            "成功次数": 0,
            "失败次数": 0,
            "超时重置次数": 0
        }
        self._上次记录的血量 = 1.0  # 用于检测血量变化
        self._血量变化阈值 = 0.05  # 血量变化超过 5% 时记录日志
    
    def 设置区域(self, 区域: Tuple[int, int, int, int]):
        """
        设置血条感兴趣区域
        
        参数:
            区域: (x, y, width, height)
            
        需求: 1.1
        """
        self.区域 = 区域
    
    def 设置颜色配置(self, 颜色配置: dict):
        """
        设置颜色配置
        
        支持单一颜色和渐变颜色配置。
        
        参数:
            颜色配置: HSV 颜色范围配置
                - 单一颜色: {"填充色": {"H_min": 0, "H_max": 10, ...}}
                - 渐变颜色: {"渐变色": [{"H_min": 0, ...}, ...]}
                
        需求: 2.2, 2.4
        """
        self._分析器 = 状态条分析器(颜色配置)
    
    def 使用预设颜色(self, 预设名称: str):
        """
        使用预设颜色配置
        
        参数:
            预设名称: "红色", "绿色", "渐变" 之一
            
        需求: 2.2
        """
        预设配置 = {
            "红色": {
                "填充色": {
                    "H_min": 0, "H_max": 10,
                    "S_min": 100, "S_max": 255,
                    "V_min": 100, "V_max": 255
                }
            },
            "绿色": {
                "填充色": {
                    "H_min": 35, "H_max": 85,
                    "S_min": 100, "S_max": 255,
                    "V_min": 100, "V_max": 255
                }
            },
            "渐变": self.渐变颜色配置
        }
        
        if 预设名称 in 预设配置:
            self.设置颜色配置(预设配置[预设名称])
        else:
            日志.warning(f"未知的预设颜色: {预设名称}，可用选项: {list(预设配置.keys())}")
    
    def 检测(self, 图像: np.ndarray) -> float:
        """
        检测血量百分比
        
        错误处理策略（需求 6.1, 6.2）:
        - 检测失败时返回上次有效值
        - 连续失败超过 5 秒返回满血（1.0）
        
        参数:
            图像: 游戏画面
            
        返回:
            血量百分比 (0.0-1.0)
            
        需求: 2.1, 2.3, 2.5, 6.1, 6.2
        """
        self._检测统计["总检测次数"] += 1
        当前时间 = time.time()
        
        if self.区域 is None:
            日志.warning("血条区域未配置")
            return 1.0
        
        if 图像 is None or 图像.size == 0:
            return self._处理检测失败("图像无效或为空", 当前时间)
        
        try:
            # 提取区域
            x, y, w, h = self.区域
            区域图像 = 图像[y:y+h, x:x+w]
            
            if 区域图像.size == 0:
                return self._处理检测失败("提取的区域图像为空", 当前时间)
            
            # 分析
            原始值, 置信度 = self._分析器.分析(区域图像)
            
            # 平滑处理
            平滑值 = self._平滑器.平滑(原始值)
            
            # 确保返回值在有效范围内
            平滑值 = min(1.0, max(0.0, 平滑值))
            
            # 检测成功，更新状态
            self._处理检测成功(平滑值, 置信度, 当前时间)
            
            return 平滑值
            
        except Exception as e:
            return self._处理检测失败(f"检测异常: {e}", 当前时间)
    
    def _处理检测成功(self, 值: float, 置信度: float, 当前时间: float):
        """
        处理检测成功的情况
        
        更新状态并记录血量变化日志（需求 5.4）
        
        参数:
            值: 检测到的血量值
            置信度: 检测置信度
            当前时间: 当前时间戳
        """
        self._上次值 = 值
        self._上次置信度 = 置信度
        self._上次有效值 = 值
        self._上次成功时间 = 当前时间
        self._连续失败次数 = 0
        self._首次失败时间 = None
        self._检测统计["成功次数"] += 1
        
        # 记录血量变化日志（需求 5.4）
        血量变化 = abs(值 - self._上次记录的血量)
        if 血量变化 >= self._血量变化阈值:
            变化方向 = "下降" if 值 < self._上次记录的血量 else "上升"
            日志.info(f"血量{变化方向}: {self._上次记录的血量*100:.1f}% -> {值*100:.1f}% (置信度: {置信度*100:.0f}%)")
            self._上次记录的血量 = 值
    
    def _处理检测失败(self, 原因: str, 当前时间: float) -> float:
        """
        处理检测失败的情况
        
        实现错误处理策略（需求 6.1, 6.2, 6.3）:
        - 返回上次有效值
        - 超时返回满血
        - 记录失败日志
        
        参数:
            原因: 失败原因
            当前时间: 当前时间戳
            
        返回:
            血量百分比
        """
        self._连续失败次数 += 1
        self._检测统计["失败次数"] += 1
        
        # 记录首次失败时间
        if self._首次失败时间 is None:
            self._首次失败时间 = 当前时间
        
        # 计算失败持续时间
        失败持续时间 = 当前时间 - self._首次失败时间
        
        # 记录检测失败日志（需求 6.3）
        日志.warning(f"血量检测失败: {原因} (连续失败: {self._连续失败次数}次, 持续: {失败持续时间:.1f}秒)")
        
        # 检查是否超时（需求 6.2）
        if 失败持续时间 >= self._失败超时:
            self._检测统计["超时重置次数"] += 1
            日志.warning(f"血量检测连续失败超过 {self._失败超时} 秒，返回满血 (1.0)")
            # 重置失败计时器
            self._首次失败时间 = 当前时间
            return 1.0
        
        # 返回上次有效值（需求 6.1）
        return self._上次有效值
    
    def 获取置信度(self) -> float:
        """获取最近一次检测的置信度"""
        return self._上次置信度
    
    def 获取颜色配置(self) -> dict:
        """获取当前颜色配置"""
        return self._分析器.获取颜色配置()
    
    def 获取检测统计(self) -> dict:
        """
        获取检测统计信息
        
        返回:
            包含检测统计的字典
            
        需求: 6.3
        """
        统计 = self._检测统计.copy()
        统计["成功率"] = (统计["成功次数"] / 统计["总检测次数"] * 100 
                        if 统计["总检测次数"] > 0 else 0.0)
        统计["当前连续失败次数"] = self._连续失败次数
        统计["上次成功时间"] = self._上次成功时间
        统计["上次有效值"] = self._上次有效值
        return 统计
    
    def 获取诊断信息(self) -> dict:
        """
        获取详细的诊断信息
        
        返回:
            包含诊断信息的字典，用于调试和问题排查
            
        需求: 6.3
        """
        return {
            "区域配置": self.区域,
            "当前值": self._上次值,
            "上次有效值": self._上次有效值,
            "置信度": self._上次置信度,
            "连续失败次数": self._连续失败次数,
            "首次失败时间": self._首次失败时间,
            "上次成功时间": self._上次成功时间,
            "失败超时设置": self._失败超时,
            "检测统计": self.获取检测统计(),
            "颜色配置": self.获取颜色配置()
        }
    
    def 设置失败超时(self, 超时秒数: float):
        """
        设置检测失败超时时间
        
        参数:
            超时秒数: 超时时间（秒），超过此时间返回满血
            
        需求: 6.2
        """
        if 超时秒数 > 0:
            self._失败超时 = 超时秒数
            日志.info(f"血量检测失败超时设置为: {超时秒数} 秒")
    
    def 重置(self):
        """重置检测器状态"""
        self._平滑器.重置()
        self._上次值 = 1.0
        self._上次置信度 = 0.0
        self._连续失败次数 = 0
        self._首次失败时间 = None
        self._上次成功时间 = time.time()
        self._上次有效值 = 1.0
        self._上次记录的血量 = 1.0
        # 重置统计
        self._检测统计 = {
            "总检测次数": 0,
            "成功次数": 0,
            "失败次数": 0,
            "超时重置次数": 0
        }
        日志.info("血量检测器已重置")


class 蓝量检测器:
    """
    检测游戏蓝条的填充百分比
    
    支持可配置的颜色范围。默认检测蓝色蓝条。
    如果未配置区域，返回 1.0（满蓝）。
    
    错误处理策略（需求 6.1, 6.2, 6.3）:
    - 检测失败时返回上次有效值
    - 连续失败超过 5 秒返回满蓝（1.0）
    - 记录所有检测失败和蓝量变化
    
    需求: 3.1, 3.2, 3.3, 3.4, 6.1, 6.2, 6.3
    """
    
    # 默认蓝色蓝条颜色范围
    默认颜色配置 = {
        "填充色": {
            "H_min": 100, "H_max": 130,  # 蓝色色调
            "S_min": 100, "S_max": 255,
            "V_min": 100, "V_max": 255
        }
    }
    
    # 预设颜色配置
    预设配置 = {
        "蓝色": {
            "填充色": {
                "H_min": 100, "H_max": 130,
                "S_min": 100, "S_max": 255,
                "V_min": 100, "V_max": 255
            }
        },
        "紫色": {
            "填充色": {
                "H_min": 130, "H_max": 160,
                "S_min": 100, "S_max": 255,
                "V_min": 100, "V_max": 255
            }
        },
        "青色": {
            "填充色": {
                "H_min": 80, "H_max": 100,
                "S_min": 100, "S_max": 255,
                "V_min": 100, "V_max": 255
            }
        }
    }
    
    # 默认失败超时时间（秒）
    默认失败超时 = 5.0
    
    def __init__(self, 配置: dict = None):
        """
        初始化蓝量检测器
        
        参数:
            配置: 检测配置字典，支持以下字段:
                - 区域: (x, y, width, height) 蓝条区域
                - 颜色: 颜色配置字典
                - 平滑窗口: 平滑窗口大小
                - 失败超时: 连续失败超时时间（秒），默认 5 秒
                
        需求: 3.1, 3.2, 6.2
        """
        self.配置 = 配置 or {}
        self.区域 = self.配置.get("区域", None)
        
        颜色配置 = self.配置.get("颜色", self.默认颜色配置)
        self._分析器 = 状态条分析器(颜色配置)
        
        窗口大小 = self.配置.get("平滑窗口", 5)
        self._平滑器 = 平滑器(窗口大小)
        
        self._上次值 = 1.0
        self._上次置信度 = 0.0
        self._连续失败次数 = 0
        self._最大连续失败 = 10
        
        # 错误处理相关（需求 6.1, 6.2）
        self._失败超时 = self.配置.get("失败超时", self.默认失败超时)
        self._首次失败时间: Optional[float] = None
        self._上次成功时间: float = time.time()
        self._上次有效值 = 1.0  # 上次成功检测的值
        
        # 日志和诊断相关（需求 5.4, 6.3）
        self._检测统计 = {
            "总检测次数": 0,
            "成功次数": 0,
            "失败次数": 0,
            "超时重置次数": 0
        }
        self._上次记录的蓝量 = 1.0  # 用于检测蓝量变化
        self._蓝量变化阈值 = 0.05  # 蓝量变化超过 5% 时记录日志
    
    def 设置区域(self, 区域: Tuple[int, int, int, int]):
        """
        设置蓝条感兴趣区域
        
        参数:
            区域: (x, y, width, height)
            
        需求: 3.1
        """
        self.区域 = 区域
    
    def 设置颜色配置(self, 颜色配置: dict):
        """
        设置颜色配置
        
        参数:
            颜色配置: HSV 颜色范围配置
            
        需求: 3.2
        """
        self._分析器 = 状态条分析器(颜色配置)
    
    def 使用预设颜色(self, 预设名称: str):
        """
        使用预设颜色配置
        
        参数:
            预设名称: "蓝色", "紫色", "青色" 之一
        """
        if 预设名称 in self.预设配置:
            self.设置颜色配置(self.预设配置[预设名称])
        else:
            日志.warning(f"未知的预设颜色: {预设名称}，可用选项: {list(self.预设配置.keys())}")
    
    def 检测(self, 图像: np.ndarray) -> float:
        """
        检测蓝量百分比
        
        错误处理策略（需求 6.1, 6.2）:
        - 检测失败时返回上次有效值
        - 连续失败超过 5 秒返回满蓝（1.0）
        
        参数:
            图像: 游戏画面
            
        返回:
            蓝量百分比 (0.0-1.0)
            如果未配置区域，返回 1.0（满蓝）
            
        需求: 3.2, 3.3, 3.4, 6.1, 6.2
        """
        # 如果未配置区域，返回满蓝（需求 3.4）
        if self.区域 is None:
            return 1.0
        
        self._检测统计["总检测次数"] += 1
        当前时间 = time.time()
        
        if 图像 is None or 图像.size == 0:
            return self._处理检测失败("图像无效或为空", 当前时间)
        
        try:
            x, y, w, h = self.区域
            区域图像 = 图像[y:y+h, x:x+w]
            
            if 区域图像.size == 0:
                return self._处理检测失败("提取的区域图像为空", 当前时间)
            
            原始值, 置信度 = self._分析器.分析(区域图像)
            平滑值 = self._平滑器.平滑(原始值)
            
            # 确保返回值在有效范围内
            平滑值 = min(1.0, max(0.0, 平滑值))
            
            # 检测成功，更新状态
            self._处理检测成功(平滑值, 置信度, 当前时间)
            
            return 平滑值
            
        except Exception as e:
            return self._处理检测失败(f"检测异常: {e}", 当前时间)
    
    def _处理检测成功(self, 值: float, 置信度: float, 当前时间: float):
        """
        处理检测成功的情况
        
        更新状态并记录蓝量变化日志（需求 5.4）
        
        参数:
            值: 检测到的蓝量值
            置信度: 检测置信度
            当前时间: 当前时间戳
        """
        self._上次值 = 值
        self._上次置信度 = 置信度
        self._上次有效值 = 值
        self._上次成功时间 = 当前时间
        self._连续失败次数 = 0
        self._首次失败时间 = None
        self._检测统计["成功次数"] += 1
        
        # 记录蓝量变化日志（需求 5.4）
        蓝量变化 = abs(值 - self._上次记录的蓝量)
        if 蓝量变化 >= self._蓝量变化阈值:
            变化方向 = "下降" if 值 < self._上次记录的蓝量 else "上升"
            日志.info(f"蓝量{变化方向}: {self._上次记录的蓝量*100:.1f}% -> {值*100:.1f}% (置信度: {置信度*100:.0f}%)")
            self._上次记录的蓝量 = 值
    
    def _处理检测失败(self, 原因: str, 当前时间: float) -> float:
        """
        处理检测失败的情况
        
        实现错误处理策略（需求 6.1, 6.2, 6.3）:
        - 返回上次有效值
        - 超时返回满蓝
        - 记录失败日志
        
        参数:
            原因: 失败原因
            当前时间: 当前时间戳
            
        返回:
            蓝量百分比
        """
        self._连续失败次数 += 1
        self._检测统计["失败次数"] += 1
        
        # 记录首次失败时间
        if self._首次失败时间 is None:
            self._首次失败时间 = 当前时间
        
        # 计算失败持续时间
        失败持续时间 = 当前时间 - self._首次失败时间
        
        # 记录检测失败日志（需求 6.3）
        日志.warning(f"蓝量检测失败: {原因} (连续失败: {self._连续失败次数}次, 持续: {失败持续时间:.1f}秒)")
        
        # 检查是否超时（需求 6.2）
        if 失败持续时间 >= self._失败超时:
            self._检测统计["超时重置次数"] += 1
            日志.warning(f"蓝量检测连续失败超过 {self._失败超时} 秒，返回满蓝 (1.0)")
            # 重置失败计时器
            self._首次失败时间 = 当前时间
            return 1.0
        
        # 返回上次有效值（需求 6.1）
        return self._上次有效值
    
    def 获取置信度(self) -> float:
        """获取最近一次检测的置信度"""
        return self._上次置信度
    
    def 获取颜色配置(self) -> dict:
        """获取当前颜色配置"""
        return self._分析器.获取颜色配置()
    
    def 获取检测统计(self) -> dict:
        """
        获取检测统计信息
        
        返回:
            包含检测统计的字典
            
        需求: 6.3
        """
        统计 = self._检测统计.copy()
        统计["成功率"] = (统计["成功次数"] / 统计["总检测次数"] * 100 
                        if 统计["总检测次数"] > 0 else 0.0)
        统计["当前连续失败次数"] = self._连续失败次数
        统计["上次成功时间"] = self._上次成功时间
        统计["上次有效值"] = self._上次有效值
        return 统计
    
    def 获取诊断信息(self) -> dict:
        """
        获取详细的诊断信息
        
        返回:
            包含诊断信息的字典，用于调试和问题排查
            
        需求: 6.3
        """
        return {
            "区域配置": self.区域,
            "当前值": self._上次值,
            "上次有效值": self._上次有效值,
            "置信度": self._上次置信度,
            "连续失败次数": self._连续失败次数,
            "首次失败时间": self._首次失败时间,
            "上次成功时间": self._上次成功时间,
            "失败超时设置": self._失败超时,
            "检测统计": self.获取检测统计(),
            "颜色配置": self.获取颜色配置()
        }
    
    def 设置失败超时(self, 超时秒数: float):
        """
        设置检测失败超时时间
        
        参数:
            超时秒数: 超时时间（秒），超过此时间返回满蓝
            
        需求: 6.2
        """
        if 超时秒数 > 0:
            self._失败超时 = 超时秒数
            日志.info(f"蓝量检测失败超时设置为: {超时秒数} 秒")
    
    def 重置(self):
        """重置检测器状态"""
        self._平滑器.重置()
        self._上次值 = 1.0
        self._上次置信度 = 0.0
        self._连续失败次数 = 0
        self._首次失败时间 = None
        self._上次成功时间 = time.time()
        self._上次有效值 = 1.0
        self._上次记录的蓝量 = 1.0
        # 重置统计
        self._检测统计 = {
            "总检测次数": 0,
            "成功次数": 0,
            "失败次数": 0,
            "超时重置次数": 0
        }
        日志.info("蓝量检测器已重置")


class 状态检测器:
    """
    统一的状态检测器，同时检测血量和蓝量
    
    提供统一的接口检测血量和蓝量，并汇总诊断信息。
    
    需求: 5.4, 6.3
    """
    
    def __init__(self, 配置: dict = None):
        """
        初始化状态检测器
        
        参数:
            配置: 检测配置字典
        """
        self.配置 = 配置 or {}
        
        血条配置 = self.配置.get("血条", {})
        蓝条配置 = self.配置.get("蓝条", {})
        
        self._血量检测器 = 血量检测器(血条配置)
        self._蓝量检测器 = 蓝量检测器(蓝条配置)
        
        # 检测统计
        self._总检测次数 = 0
    
    def 检测(self, 图像: np.ndarray) -> 状态检测结果:
        """
        检测血量和蓝量
        
        参数:
            图像: 游戏画面
            
        返回:
            状态检测结果
        """
        开始时间 = time.time()
        self._总检测次数 += 1
        
        血量 = self._血量检测器.检测(图像)
        蓝量 = self._蓝量检测器.检测(图像)
        
        检测时间 = time.time() - 开始时间
        
        # 记录慢检测警告
        if 检测时间 > 0.1:  # 超过 100ms 记录警告
            日志.warning(f"状态检测耗时过长: {检测时间*1000:.1f}ms")
        
        return 状态检测结果(
            血量百分比=血量,
            蓝量百分比=蓝量,
            血量置信度=self._血量检测器.获取置信度(),
            蓝量置信度=self._蓝量检测器.获取置信度(),
            检测时间=检测时间
        )
    
    def 设置血条区域(self, 区域: Tuple[int, int, int, int]):
        """设置血条区域"""
        self._血量检测器.设置区域(区域)
        日志.info(f"血条区域已设置: {区域}")
    
    def 设置蓝条区域(self, 区域: Tuple[int, int, int, int]):
        """设置蓝条区域"""
        self._蓝量检测器.设置区域(区域)
        日志.info(f"蓝条区域已设置: {区域}")
    
    def 获取诊断信息(self) -> dict:
        """
        获取完整的诊断信息
        
        返回:
            包含血量和蓝量检测器诊断信息的字典
            
        需求: 6.3
        """
        return {
            "总检测次数": self._总检测次数,
            "血量检测器": self._血量检测器.获取诊断信息(),
            "蓝量检测器": self._蓝量检测器.获取诊断信息()
        }
    
    def 获取检测统计(self) -> dict:
        """
        获取检测统计汇总
        
        返回:
            包含血量和蓝量检测统计的字典
            
        需求: 6.3
        """
        血量统计 = self._血量检测器.获取检测统计()
        蓝量统计 = self._蓝量检测器.获取检测统计()
        
        return {
            "总检测次数": self._总检测次数,
            "血量检测": 血量统计,
            "蓝量检测": 蓝量统计,
            "总成功率": (
                (血量统计["成功次数"] + 蓝量统计["成功次数"]) / 
                (血量统计["总检测次数"] + 蓝量统计["总检测次数"]) * 100
                if (血量统计["总检测次数"] + 蓝量统计["总检测次数"]) > 0 else 0.0
            )
        }
    
    def 打印诊断报告(self):
        """
        打印详细的诊断报告到日志
        
        需求: 6.3
        """
        诊断 = self.获取诊断信息()
        统计 = self.获取检测统计()
        
        日志.info("=" * 50)
        日志.info("状态检测诊断报告")
        日志.info("=" * 50)
        日志.info(f"总检测次数: {统计['总检测次数']}")
        日志.info(f"总成功率: {统计['总成功率']:.1f}%")
        日志.info("-" * 50)
        日志.info("血量检测:")
        日志.info(f"  区域: {诊断['血量检测器']['区域配置']}")
        日志.info(f"  当前值: {诊断['血量检测器']['当前值']*100:.1f}%")
        日志.info(f"  置信度: {诊断['血量检测器']['置信度']*100:.0f}%")
        日志.info(f"  成功率: {统计['血量检测']['成功率']:.1f}%")
        日志.info(f"  失败次数: {统计['血量检测']['失败次数']}")
        日志.info(f"  超时重置: {统计['血量检测']['超时重置次数']}")
        日志.info("-" * 50)
        日志.info("蓝量检测:")
        日志.info(f"  区域: {诊断['蓝量检测器']['区域配置']}")
        日志.info(f"  当前值: {诊断['蓝量检测器']['当前值']*100:.1f}%")
        日志.info(f"  置信度: {诊断['蓝量检测器']['置信度']*100:.0f}%")
        日志.info(f"  成功率: {统计['蓝量检测']['成功率']:.1f}%")
        日志.info(f"  失败次数: {统计['蓝量检测']['失败次数']}")
        日志.info(f"  超时重置: {统计['蓝量检测']['超时重置次数']}")
        日志.info("=" * 50)
    
    def 设置失败超时(self, 超时秒数: float):
        """
        设置检测失败超时时间（同时应用于血量和蓝量检测器）
        
        参数:
            超时秒数: 超时时间（秒）
            
        需求: 6.2
        """
        self._血量检测器.设置失败超时(超时秒数)
        self._蓝量检测器.设置失败超时(超时秒数)
    
    def 重置(self):
        """重置所有检测器状态"""
        self._血量检测器.重置()
        self._蓝量检测器.重置()
        self._总检测次数 = 0
        日志.info("状态检测器已重置")
    
    def 从配置加载(self, 配置路径: str):
        """从配置文件加载"""
        with open(配置路径, 'r', encoding='utf-8') as f:
            配置 = json.load(f)
        
        if "血条" in 配置:
            血条配置 = 配置["血条"]
            if "区域" in 血条配置:
                self._血量检测器.设置区域(tuple(血条配置["区域"]))
            if "颜色" in 血条配置:
                self._血量检测器.设置颜色配置(血条配置["颜色"])
        
        if "蓝条" in 配置:
            蓝条配置 = 配置["蓝条"]
            if "区域" in 蓝条配置:
                self._蓝量检测器.设置区域(tuple(蓝条配置["区域"]))
            if "颜色" in 蓝条配置:
                self._蓝量检测器.设置颜色配置(蓝条配置["颜色"])
    
    def 保存配置(self, 配置路径: str):
        """保存配置到文件"""
        配置 = {
            "血条": {
                "区域": list(self._血量检测器.区域) if self._血量检测器.区域 else None,
                "颜色": self._血量检测器._分析器.颜色配置
            },
            "蓝条": {
                "区域": list(self._蓝量检测器.区域) if self._蓝量检测器.区域 else None,
                "颜色": self._蓝量检测器._分析器.颜色配置
            }
        }
        
        os.makedirs(os.path.dirname(配置路径) or '.', exist_ok=True)
        with open(配置路径, 'w', encoding='utf-8') as f:
            json.dump(配置, f, ensure_ascii=False, indent=2)


class 校准工具:
    """
    血条/蓝条区域校准工具
    
    提供交互式界面帮助用户选择状态条区域，支持：
    - 鼠标拖拽选择区域
    - 实时预览选中区域和检测结果
    - 配置保存和加载
    - 多游戏配置支持
    
    需求: 1.2, 1.3, 1.4, 1.5
    """
    
    # 默认配置目录
    默认配置目录 = "配置/状态检测"
    
    def __init__(self, 配置目录: str = None):
        """
        初始化校准工具
        
        参数:
            配置目录: 配置文件保存目录，默认为 "配置/状态检测"
        """
        self._配置目录 = 配置目录 or self.默认配置目录
        self._当前类型 = "血条"
        self._选中区域: Optional[Tuple[int, int, int, int]] = None
        self._预览窗口名 = "状态条校准"
        
        # 鼠标选择状态
        self._正在选择 = False
        self._起始点: Optional[Tuple[int, int]] = None
        self._当前点: Optional[Tuple[int, int]] = None
        self._选择完成 = False
        
        # 原始图像（用于鼠标回调）
        self._原始图像: Optional[np.ndarray] = None
        
        # 分析器（用于实时预览检测结果）
        self._血量分析器 = 状态条分析器(血量检测器.默认颜色配置)
        self._蓝量分析器 = 状态条分析器(蓝量检测器.默认颜色配置)
        
        # 确保配置目录存在
        os.makedirs(self._配置目录, exist_ok=True)
    
    def _鼠标回调(self, 事件: int, x: int, y: int, 标志: int, 参数):
        """
        鼠标事件回调函数
        
        处理鼠标拖拽选择区域的交互
        
        需求: 1.2
        """
        if 事件 == cv2.EVENT_LBUTTONDOWN:
            # 开始选择
            self._正在选择 = True
            self._起始点 = (x, y)
            self._当前点 = (x, y)
            self._选择完成 = False
            
        elif 事件 == cv2.EVENT_MOUSEMOVE:
            # 更新当前点
            if self._正在选择:
                self._当前点 = (x, y)
                
        elif 事件 == cv2.EVENT_LBUTTONUP:
            # 完成选择
            if self._正在选择:
                self._正在选择 = False
                self._当前点 = (x, y)
                
                # 计算选中区域
                if self._起始点 and self._当前点:
                    x1, y1 = self._起始点
                    x2, y2 = self._当前点
                    
                    # 确保坐标正确（左上角到右下角）
                    左 = min(x1, x2)
                    上 = min(y1, y2)
                    右 = max(x1, x2)
                    下 = max(y1, y2)
                    
                    宽度 = 右 - 左
                    高度 = 下 - 上
                    
                    # 只有当区域有效时才保存
                    if 宽度 > 5 and 高度 > 3:
                        self._选中区域 = (左, 上, 宽度, 高度)
                        self._选择完成 = True
    
    def _获取颜色(self, 类型: str) -> Tuple[int, int, int]:
        """获取指定类型的显示颜色"""
        if 类型 == "血条":
            return (0, 255, 0)  # 绿色边框
        else:
            return (255, 0, 0)  # 蓝色边框
    
    def _绘制选择框(self, 图像: np.ndarray) -> np.ndarray:
        """
        绘制当前选择框
        
        需求: 1.3
        """
        显示图 = 图像.copy()
        颜色 = self._获取颜色(self._当前类型)
        
        # 绘制正在选择的区域
        if self._正在选择 and self._起始点 and self._当前点:
            x1, y1 = self._起始点
            x2, y2 = self._当前点
            cv2.rectangle(显示图, (x1, y1), (x2, y2), 颜色, 2)
        
        # 绘制已选中的区域
        if self._选中区域:
            x, y, w, h = self._选中区域
            cv2.rectangle(显示图, (x, y), (x + w, y + h), 颜色, 2)
            
            # 添加标签
            标签 = f"{self._当前类型}"
            cv2.putText(显示图, 标签, (x, y - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, 颜色, 2)
            
            # 显示检测结果预览
            if self._原始图像 is not None:
                区域图像 = self._原始图像[y:y+h, x:x+w]
                if 区域图像.size > 0:
                    分析器 = self._血量分析器 if self._当前类型 == "血条" else self._蓝量分析器
                    百分比, 置信度 = 分析器.分析(区域图像)
                    
                    # 显示检测结果
                    结果文本 = f"{百分比*100:.1f}% (置信度: {置信度*100:.0f}%)"
                    cv2.putText(显示图, 结果文本, (x, y + h + 20),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.5, 颜色, 1)
        
        return 显示图
    
    def _绘制帮助信息(self, 图像: np.ndarray) -> np.ndarray:
        """绘制操作帮助信息"""
        显示图 = 图像.copy()
        高度 = 图像.shape[0]
        
        帮助文本 = [
            f"正在校准: {self._当前类型}",
            "操作说明:",
            "  鼠标拖拽 - 选择区域",
            "  Enter - 确认选择",
            "  R - 重新选择",
            "  ESC - 取消"
        ]
        
        y位置 = 高度 - 120
        for 文本 in 帮助文本:
            cv2.putText(显示图, 文本, (10, y位置),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
            y位置 += 20
        
        return 显示图
    
    def 启动校准(self, 图像: np.ndarray, 类型: str = "血条") -> Optional[Tuple[int, int, int, int]]:
        """
        启动交互式校准流程
        
        使用 OpenCV 窗口提供鼠标拖拽选择区域的界面。
        
        参数:
            图像: 游戏画面
            类型: "血条" 或 "蓝条"
            
        返回:
            选中的区域 (x, y, width, height)，取消则返回 None
            
        需求: 1.2, 1.3
        """
        if 图像 is None or 图像.size == 0:
            日志.error("校准失败: 图像无效")
            return None
        
        self._当前类型 = 类型
        self._原始图像 = 图像.copy()
        self._选中区域 = None
        self._选择完成 = False
        self._正在选择 = False
        
        # 创建窗口并设置鼠标回调
        窗口名 = f"{self._预览窗口名} - {类型}"
        cv2.namedWindow(窗口名, cv2.WINDOW_NORMAL)
        cv2.setMouseCallback(窗口名, self._鼠标回调)
        
        日志.info(f"开始 {类型} 区域校准，请用鼠标拖拽选择区域")
        
        try:
            while True:
                # 绘制当前状态
                显示图 = self._绘制选择框(self._原始图像)
                显示图 = self._绘制帮助信息(显示图)
                
                cv2.imshow(窗口名, 显示图)
                
                键值 = cv2.waitKey(30) & 0xFF
                
                if 键值 == 27:  # ESC - 取消
                    日志.info("校准已取消")
                    self._选中区域 = None
                    break
                    
                elif 键值 == 13:  # Enter - 确认
                    if self._选中区域:
                        日志.info(f"已确认 {类型} 区域: {self._选中区域}")
                        break
                    else:
                        日志.warning("请先选择一个区域")
                        
                elif 键值 == ord('r') or 键值 == ord('R'):  # R - 重新选择
                    self._选中区域 = None
                    self._选择完成 = False
                    日志.info("已重置选择，请重新拖拽选择区域")
                    
        finally:
            cv2.destroyWindow(窗口名)
        
        return self._选中区域
    
    def 启动命令行校准(self, 图像: np.ndarray, 类型: str = "血条") -> Optional[Tuple[int, int, int, int]]:
        """
        启动命令行校准流程（无 GUI 环境使用）
        
        参数:
            图像: 游戏画面
            类型: "血条" 或 "蓝条"
            
        返回:
            选中的区域 (x, y, width, height)
        """
        self._当前类型 = 类型
        
        print(f"\n{'='*50}")
        print(f"📍 {类型}区域校准")
        print(f"{'='*50}")
        print(f"图像尺寸: {图像.shape[1]} x {图像.shape[0]}")
        print("\n请输入状态条区域坐标:")
        
        try:
            x = int(input("  X 坐标: "))
            y = int(input("  Y 坐标: "))
            w = int(input("  宽度: "))
            h = int(input("  高度: "))
            
            self._选中区域 = (x, y, w, h)
            print(f"\n✅ 已选择区域: {self._选中区域}")
            return self._选中区域
            
        except ValueError as e:
            print(f"❌ 输入无效: {e}")
            return None
    
    def 预览区域(self, 图像: np.ndarray, 区域: Tuple[int, int, int, int], 
                类型: str = None, 显示检测结果: bool = True) -> np.ndarray:
        """
        预览选中区域
        
        在图像上绘制选中区域的高亮框，并可选显示检测结果。
        
        参数:
            图像: 原始图像
            区域: (x, y, width, height)
            类型: "血条" 或 "蓝条"，默认使用当前类型
            显示检测结果: 是否显示检测百分比
            
        返回:
            带标注的预览图像
            
        需求: 1.3
        """
        if 图像 is None or 图像.size == 0:
            return 图像
        
        预览图 = 图像.copy()
        类型 = 类型 or self._当前类型
        x, y, w, h = 区域
        
        # 绘制矩形边框
        颜色 = self._获取颜色(类型)
        cv2.rectangle(预览图, (x, y), (x + w, y + h), 颜色, 2)
        
        # 添加标签
        cv2.putText(预览图, 类型, (x, y - 10),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, 颜色, 2)
        
        # 显示检测结果
        if 显示检测结果:
            区域图像 = 图像[y:y+h, x:x+w]
            if 区域图像.size > 0:
                分析器 = self._血量分析器 if 类型 == "血条" else self._蓝量分析器
                百分比, 置信度 = 分析器.分析(区域图像)
                
                结果文本 = f"{百分比*100:.1f}%"
                cv2.putText(预览图, 结果文本, (x, y + h + 20),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, 颜色, 1)
        
        return 预览图
    
    def 预览多区域(self, 图像: np.ndarray, 血条区域: tuple = None, 
                  蓝条区域: tuple = None) -> np.ndarray:
        """
        同时预览血条和蓝条区域
        
        参数:
            图像: 原始图像
            血条区域: 血条区域 (x, y, width, height)
            蓝条区域: 蓝条区域 (x, y, width, height)
            
        返回:
            带标注的预览图像
        """
        预览图 = 图像.copy()
        
        if 血条区域:
            预览图 = self.预览区域(预览图, 血条区域, "血条")
        
        if 蓝条区域:
            预览图 = self.预览区域(预览图, 蓝条区域, "蓝条")
        
        return 预览图
    
    def 保存配置(self, 配置名称: str, 血条区域: tuple = None, 蓝条区域: tuple = None,
                血条颜色: dict = None, 蓝条颜色: dict = None, 游戏名称: str = None):
        """
        保存校准配置到文件
        
        支持保存多个游戏的配置，每个配置包含区域和颜色设置。
        
        参数:
            配置名称: 配置文件名（不含扩展名）
            血条区域: 血条区域 (x, y, width, height)
            蓝条区域: 蓝条区域 (x, y, width, height)
            血条颜色: 血条颜色配置
            蓝条颜色: 蓝条颜色配置
            游戏名称: 游戏名称（用于标识）
            
        需求: 1.4, 1.5
        """
        配置 = {
            "游戏名称": 游戏名称 or 配置名称,
            "创建时间": time.strftime("%Y-%m-%d %H:%M:%S"),
            "血条": {},
            "蓝条": {}
        }
        
        if 血条区域:
            配置["血条"]["区域"] = list(血条区域)
        if 血条颜色:
            配置["血条"]["颜色"] = 血条颜色
        
        if 蓝条区域:
            配置["蓝条"]["区域"] = list(蓝条区域)
        if 蓝条颜色:
            配置["蓝条"]["颜色"] = 蓝条颜色
        
        # 确保目录存在
        os.makedirs(self._配置目录, exist_ok=True)
        
        配置路径 = os.path.join(self._配置目录, f"{配置名称}.json")
        with open(配置路径, 'w', encoding='utf-8') as f:
            json.dump(配置, f, ensure_ascii=False, indent=2)
        
        日志.info(f"配置已保存: {配置路径}")
        return 配置路径
    
    def 加载配置(self, 配置名称: str) -> Optional[dict]:
        """
        加载校准配置
        
        参数:
            配置名称: 配置文件名（不含扩展名）
            
        返回:
            配置字典，加载失败返回 None
            
        需求: 1.4, 1.5
        """
        配置路径 = os.path.join(self._配置目录, f"{配置名称}.json")
        
        if not os.path.exists(配置路径):
            日志.warning(f"配置文件不存在: {配置路径}")
            return None
        
        try:
            with open(配置路径, 'r', encoding='utf-8') as f:
                配置 = json.load(f)
            
            日志.info(f"配置已加载: {配置路径}")
            return 配置
            
        except Exception as e:
            日志.error(f"加载配置失败: {e}")
            return None
    
    def 列出配置(self) -> List[str]:
        """
        列出所有可用的配置
        
        返回:
            配置名称列表
            
        需求: 1.5
        """
        if not os.path.exists(self._配置目录):
            return []
        
        配置列表 = []
        for 文件名 in os.listdir(self._配置目录):
            if 文件名.endswith('.json'):
                配置列表.append(文件名[:-5])  # 去掉 .json 扩展名
        
        return sorted(配置列表)
    
    def 删除配置(self, 配置名称: str) -> bool:
        """
        删除指定配置
        
        参数:
            配置名称: 配置文件名（不含扩展名）
            
        返回:
            是否删除成功
        """
        配置路径 = os.path.join(self._配置目录, f"{配置名称}.json")
        
        if not os.path.exists(配置路径):
            日志.warning(f"配置文件不存在: {配置路径}")
            return False
        
        try:
            os.remove(配置路径)
            日志.info(f"配置已删除: {配置路径}")
            return True
        except Exception as e:
            日志.error(f"删除配置失败: {e}")
            return False
    
    def 应用配置到检测器(self, 配置: dict, 状态检测器实例: '状态检测器') -> bool:
        """
        将配置应用到状态检测器
        
        参数:
            配置: 配置字典
            状态检测器实例: 状态检测器实例
            
        返回:
            是否应用成功
        """
        try:
            if "血条" in 配置:
                血条配置 = 配置["血条"]
                if "区域" in 血条配置:
                    状态检测器实例.设置血条区域(tuple(血条配置["区域"]))
                if "颜色" in 血条配置:
                    状态检测器实例._血量检测器.设置颜色配置(血条配置["颜色"])
            
            if "蓝条" in 配置:
                蓝条配置 = 配置["蓝条"]
                if "区域" in 蓝条配置:
                    状态检测器实例.设置蓝条区域(tuple(蓝条配置["区域"]))
                if "颜色" in 蓝条配置:
                    状态检测器实例._蓝量检测器.设置颜色配置(蓝条配置["颜色"])
            
            日志.info("配置已应用到检测器")
            return True
            
        except Exception as e:
            日志.error(f"应用配置失败: {e}")
            return False
    
    def 获取配置目录(self) -> str:
        """获取配置目录路径"""
        return self._配置目录
    
    def 设置配置目录(self, 目录: str):
        """设置配置目录路径"""
        self._配置目录 = 目录
        os.makedirs(self._配置目录, exist_ok=True)


class 状态检测配置管理器:
    """
    状态检测配置管理器
    
    管理多个游戏的状态检测配置，支持：
    - 配置的保存、加载、删除
    - 配置切换
    - 配置导入导出
    
    需求: 1.4, 1.5
    """
    
    默认配置目录 = "配置/状态检测"
    当前配置文件 = "当前配置.txt"
    
    def __init__(self, 配置目录: str = None):
        """
        初始化配置管理器
        
        参数:
            配置目录: 配置文件保存目录
        """
        self._配置目录 = 配置目录 or self.默认配置目录
        self._当前配置名: Optional[str] = None
        self._当前配置: Optional[dict] = None
        self._校准工具 = 校准工具(self._配置目录)
        
        # 确保配置目录存在
        os.makedirs(self._配置目录, exist_ok=True)
        
        # 尝试加载上次使用的配置
        self._加载上次配置()
    
    def _加载上次配置(self):
        """加载上次使用的配置"""
        当前配置路径 = os.path.join(self._配置目录, self.当前配置文件)
        
        if os.path.exists(当前配置路径):
            try:
                with open(当前配置路径, 'r', encoding='utf-8') as f:
                    配置名 = f.read().strip()
                
                if 配置名 and self.配置存在(配置名):
                    self.切换配置(配置名)
                    日志.info(f"已加载上次配置: {配置名}")
            except Exception as e:
                日志.warning(f"加载上次配置失败: {e}")
    
    def _保存当前配置名(self):
        """保存当前配置名到文件"""
        if self._当前配置名:
            当前配置路径 = os.path.join(self._配置目录, self.当前配置文件)
            try:
                with open(当前配置路径, 'w', encoding='utf-8') as f:
                    f.write(self._当前配置名)
            except Exception as e:
                日志.warning(f"保存当前配置名失败: {e}")
    
    def 配置存在(self, 配置名称: str) -> bool:
        """检查配置是否存在"""
        配置路径 = os.path.join(self._配置目录, f"{配置名称}.json")
        return os.path.exists(配置路径)
    
    def 列出所有配置(self) -> List[dict]:
        """
        列出所有配置及其详细信息
        
        返回:
            配置信息列表，每个元素包含 name, game_name, created_time
        """
        配置列表 = []
        
        for 配置名 in self._校准工具.列出配置():
            配置 = self._校准工具.加载配置(配置名)
            if 配置:
                配置列表.append({
                    "name": 配置名,
                    "game_name": 配置.get("游戏名称", 配置名),
                    "created_time": 配置.get("创建时间", "未知"),
                    "has_health": "区域" in 配置.get("血条", {}),
                    "has_mana": "区域" in 配置.get("蓝条", {})
                })
        
        return 配置列表
    
    def 创建配置(self, 配置名称: str, 游戏名称: str = None,
                血条区域: tuple = None, 蓝条区域: tuple = None,
                血条颜色: dict = None, 蓝条颜色: dict = None) -> bool:
        """
        创建新配置
        
        参数:
            配置名称: 配置名称
            游戏名称: 游戏名称
            血条区域: 血条区域
            蓝条区域: 蓝条区域
            血条颜色: 血条颜色配置
            蓝条颜色: 蓝条颜色配置
            
        返回:
            是否创建成功
            
        需求: 1.4, 1.5
        """
        try:
            self._校准工具.保存配置(
                配置名称=配置名称,
                游戏名称=游戏名称,
                血条区域=血条区域,
                蓝条区域=蓝条区域,
                血条颜色=血条颜色,
                蓝条颜色=蓝条颜色
            )
            return True
        except Exception as e:
            日志.error(f"创建配置失败: {e}")
            return False
    
    def 切换配置(self, 配置名称: str) -> bool:
        """
        切换到指定配置
        
        参数:
            配置名称: 配置名称
            
        返回:
            是否切换成功
            
        需求: 1.5
        """
        配置 = self._校准工具.加载配置(配置名称)
        
        if 配置 is None:
            日志.error(f"配置不存在: {配置名称}")
            return False
        
        self._当前配置名 = 配置名称
        self._当前配置 = 配置
        self._保存当前配置名()
        
        日志.info(f"已切换到配置: {配置名称}")
        return True
    
    def 获取当前配置(self) -> Optional[dict]:
        """获取当前配置"""
        return self._当前配置
    
    def 获取当前配置名(self) -> Optional[str]:
        """获取当前配置名称"""
        return self._当前配置名
    
    def 更新当前配置(self, 血条区域: tuple = None, 蓝条区域: tuple = None,
                    血条颜色: dict = None, 蓝条颜色: dict = None) -> bool:
        """
        更新当前配置
        
        参数:
            血条区域: 新的血条区域
            蓝条区域: 新的蓝条区域
            血条颜色: 新的血条颜色配置
            蓝条颜色: 新的蓝条颜色配置
            
        返回:
            是否更新成功
        """
        if not self._当前配置名:
            日志.error("没有当前配置")
            return False
        
        # 更新配置
        if 血条区域:
            if "血条" not in self._当前配置:
                self._当前配置["血条"] = {}
            self._当前配置["血条"]["区域"] = list(血条区域)
        
        if 蓝条区域:
            if "蓝条" not in self._当前配置:
                self._当前配置["蓝条"] = {}
            self._当前配置["蓝条"]["区域"] = list(蓝条区域)
        
        if 血条颜色:
            if "血条" not in self._当前配置:
                self._当前配置["血条"] = {}
            self._当前配置["血条"]["颜色"] = 血条颜色
        
        if 蓝条颜色:
            if "蓝条" not in self._当前配置:
                self._当前配置["蓝条"] = {}
            self._当前配置["蓝条"]["颜色"] = 蓝条颜色
        
        # 保存配置
        return self.创建配置(
            配置名称=self._当前配置名,
            游戏名称=self._当前配置.get("游戏名称"),
            血条区域=tuple(self._当前配置.get("血条", {}).get("区域", [])) or None,
            蓝条区域=tuple(self._当前配置.get("蓝条", {}).get("区域", [])) or None,
            血条颜色=self._当前配置.get("血条", {}).get("颜色"),
            蓝条颜色=self._当前配置.get("蓝条", {}).get("颜色")
        )
    
    def 删除配置(self, 配置名称: str) -> bool:
        """
        删除指定配置
        
        参数:
            配置名称: 配置名称
            
        返回:
            是否删除成功
        """
        if 配置名称 == self._当前配置名:
            self._当前配置名 = None
            self._当前配置 = None
        
        return self._校准工具.删除配置(配置名称)
    
    def 导出配置(self, 配置名称: str, 导出路径: str) -> bool:
        """
        导出配置到指定路径
        
        参数:
            配置名称: 配置名称
            导出路径: 导出文件路径
            
        返回:
            是否导出成功
        """
        配置 = self._校准工具.加载配置(配置名称)
        
        if 配置 is None:
            return False
        
        try:
            os.makedirs(os.path.dirname(导出路径) or '.', exist_ok=True)
            with open(导出路径, 'w', encoding='utf-8') as f:
                json.dump(配置, f, ensure_ascii=False, indent=2)
            
            日志.info(f"配置已导出: {导出路径}")
            return True
            
        except Exception as e:
            日志.error(f"导出配置失败: {e}")
            return False
    
    def 导入配置(self, 导入路径: str, 配置名称: str = None) -> bool:
        """
        从指定路径导入配置
        
        参数:
            导入路径: 导入文件路径
            配置名称: 配置名称（默认使用文件名）
            
        返回:
            是否导入成功
        """
        if not os.path.exists(导入路径):
            日志.error(f"导入文件不存在: {导入路径}")
            return False
        
        try:
            with open(导入路径, 'r', encoding='utf-8') as f:
                配置 = json.load(f)
            
            # 确定配置名称
            if not 配置名称:
                配置名称 = os.path.splitext(os.path.basename(导入路径))[0]
            
            # 保存配置
            配置路径 = os.path.join(self._配置目录, f"{配置名称}.json")
            with open(配置路径, 'w', encoding='utf-8') as f:
                json.dump(配置, f, ensure_ascii=False, indent=2)
            
            日志.info(f"配置已导入: {配置名称}")
            return True
            
        except Exception as e:
            日志.error(f"导入配置失败: {e}")
            return False
    
    def 应用到检测器(self, 检测器: '状态检测器') -> bool:
        """
        将当前配置应用到状态检测器
        
        参数:
            检测器: 状态检测器实例
            
        返回:
            是否应用成功
        """
        if not self._当前配置:
            日志.warning("没有当前配置")
            return False
        
        return self._校准工具.应用配置到检测器(self._当前配置, 检测器)
    
    def 获取校准工具(self) -> '校准工具':
        """获取校准工具实例"""
        return self._校准工具
