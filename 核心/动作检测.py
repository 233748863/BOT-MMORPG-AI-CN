"""
动作检测模块
用于检测游戏画面中的动作变化
"""

import cv2
import numpy as np


def 计算帧差(帧1, 帧2, 帧3):
    """
    计算三帧之间的差异
    
    参数:
        帧1: 第一帧图像
        帧2: 第二帧图像
        帧3: 第三帧图像
    
    返回:
        差异图像
    """
    差异 = cv2.absdiff(帧3, 帧1)
    return 差异


def 检测动作变化(前帧, 当前帧, 后帧, 屏幕):
    """
    检测画面中的动作变化量
    
    参数:
        前帧: 前一帧图像
        当前帧: 当前帧图像
        后帧: 后一帧图像
        屏幕: 当前屏幕图像
    
    返回:
        int: 动作变化量 (非零像素数)
    """
    # 计算帧差
    差异图 = 计算帧差(前帧, 当前帧, 后帧)
    
    # 阈值处理
    _, 差异图 = cv2.threshold(差异图, 16, 255, 3)
    
    # 归一化
    cv2.normalize(差异图, 差异图, 0, 255, cv2.NORM_MINMAX)
    
    # 转换为灰度图
    灰度图 = cv2.cvtColor(差异图, cv2.COLOR_RGB2GRAY)
    
    # 计算非零像素数
    动作量 = cv2.countNonZero(灰度图)
    
    return 动作量


def 检测是否卡住(动作日志, 阈值=800):
    """
    检测角色是否卡住 (动作量过低)
    
    参数:
        动作日志: 最近的动作量列表
        阈值: 判断卡住的阈值
    
    返回:
        bool: 是否卡住
    """
    if len(动作日志) < 10:
        return False
    
    平均动作量 = sum(动作日志) / len(动作日志)
    return 平均动作量 < 阈值


def 获取动作可视化(前帧, 当前帧, 后帧, 屏幕, 透明度=0.6):
    """
    获取动作检测的可视化图像
    
    参数:
        前帧: 前一帧图像
        当前帧: 当前帧图像
        后帧: 后一帧图像
        屏幕: 当前屏幕图像
        透明度: 叠加透明度
    
    返回:
        叠加后的可视化图像
    """
    差异图 = 计算帧差(前帧, 当前帧, 后帧)
    _, 差异图 = cv2.threshold(差异图, 16, 255, 3)
    cv2.normalize(差异图, 差异图, 0, 255, cv2.NORM_MINMAX)
    
    # 叠加到原图
    可视化图 = cv2.addWeighted(屏幕, 1.0, 差异图, 透明度, 0)
    
    return 可视化图


# 兼容原项目的函数名
motion_detection = 检测动作变化
delta_images = 计算帧差


if __name__ == "__main__":
    print("动作检测模块测试")
    
    # 创建测试图像
    帧1 = np.random.randint(0, 256, (270, 480, 3), dtype=np.uint8)
    帧2 = np.random.randint(0, 256, (270, 480, 3), dtype=np.uint8)
    帧3 = np.random.randint(0, 256, (270, 480, 3), dtype=np.uint8)
    
    动作量 = 检测动作变化(帧1, 帧2, 帧3, 帧3)
    print(f"检测到的动作量: {动作量}")
    
    # 测试卡住检测
    动作日志 = [100, 150, 120, 80, 90, 110, 130, 100, 95, 105]
    是否卡住 = 检测是否卡住(动作日志, 阈值=800)
    print(f"是否卡住: {是否卡住}")
    
    print("测试完成!")
